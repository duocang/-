##数据库设计流程

一个好的数据库应该：

+ 去除冗余数据以节省磁盘空间
+ 保证数据的完整性和正确性
+ 提供访问数据的有用方式

设计一个高效的、有用的的数据库涉及到以下几个流程：

1. 需求分析，或定义数据库的使用目的
2. 将数据组织在表中
3. 找出主键并分析关系
4. 将表做归一化

下面我们仔细看看每一步的细节。

### 需求分析：定义数据库使用的目的
明白数据库的目的能够在设计数据库的过程中持续提醒我们。保证我们考虑数据的每一个层面。例如，我们给公共图书款设计数据库，我们需要考虑顾客和管理员都会访问数据库的数据。

下面提供了建库前几种收集信息的几种方式：

+ 同使用者交流
+ 分析事物表格，如收据、时间表、调研表等
+ 梳理已有数据（包括物理的和电子的）

将所有已有数据纳入其中。列举出数据的类型和实体，或者人、事、物。如：

**顾客**

+ 姓名
+ 地址
+ 城市、省、邮编
+ 电话

**产品**

+ 名称
+ 价格
+ 数量

**订单**

+ 订单号
+ 销售代表
+ 日期
+ 产品
+ 数量
+ 价格
+ 合计

这些信息将会变为**数据字典**的一部分，它们大致描述了数据库中的表和属性。确保这些信息被划分为最小的有用块。比如将地址和国家分开，这样在之后我们可以直接使用国家做操作。同时，避免将同一数据放入多个表中，除了徒增冗余没有实质意义。

**一旦我们知道了数据库将包含什么数据、数据从何而来、数据将如何被使用，我们方可真正开始规划数据库。**

### 数据库结构：搭建数据库的一个模块

第二步是布置数据库的视觉表示。为此，我们需要理解数据库适合被**组织**的。

数据库中，相关数据被归入表中，包括行和列。

为了将数据置于表中，我们开始为每个实体创建表，如商品、销售、客户和订单。每一行被称为**记录**。记录包括包含了人或物，如客户。相反，列（又叫域或者属性）是信息的一个类型，它出现在每一个记录中，比如客户的地址或者性取向。

First Name |	Last Name |	Age	 | ZIP Code
--- | --- | --- | --- 
Roger	|Williams	|43|	34760
Jerrica|	Jorgensen	|32|	97453

为了保证数据记录间的连续性，分配合适的数据类型也很重要。

+ CHAR \- 一定长度的文本
+ VARCHAR \-   不定长文本
+ TEXT \- 大量文本
+ FLOAT, DOUBLE \- 浮点型数据
+ BLOB \- 二进制数据

为了完成数据库的数据总览，以er图为例，我们不需要包含真的表。相反，每一个表变作了一个框框，包含了数据类型：

|学生|
|---|
|学号 <br>生日 <br>年级|

终于，我们应该大概也许可能应该能够决定哪个或者哪些属性能够作为主键。一个**主键**是一个实体的**标识**，意味着它能唯一地识别。
属性作为主键应该唯一、不可更改并存在（不能为null或者空）。为此，订单号和用户名是比较好的主键，而电话号码或者地址却不是。主键总可以任意组合，组合主键被叫做复合主键。

当真的开始创建数据库时，我们将要将逻辑数据结构和物理数据结构放入数据库管理系统支持的数据定义语言中。此刻，我们需要估算数据的大小以期获得其所需的性能水平和存储空间。

### 创建实体键的关系

我们现在开始分析表之间的关系。**势（cardinality）**是指两两相关表之间互动元素的数量。确定势有利于我们帮助我们确认数据已经有效地分入表中。

实体与实体之间会有发生关系的潜在可能，所有的关系可归为三类：

1. 一对一关系
中华人民共和国是中国的唯一合法政府；中国的唯一合法政府是中华人民共和国。


2. 一对多关系
中央政府下有台湾省政府、江苏省政府等.

3. 多对多关系
大陆讨厌台湾的人和台湾讨厌大陆的人，就是典型的多对多。

#### 强制与否
分析关系的另一种方式就是考虑哪一个必须先于哪一个。中华人民共和国之于台湾，皮之不存毛将焉附？

#### 递归关系
有时表又通向自己。例如，中国人下面又有一个台湾人，而台湾人有在中国人的范畴。

#### 冗余关系
冗余关系是指表达过多次的关系。通常，我们可以移除一个关系而不丢失信息。学生和老师有着直接的关系，而学生有通过班级与老师有着间接的关系。

### 数据库归一化
一旦我们有了数据库的初步设计，我们可以使用归一化准则确保表的正确结构构建。这些准则可以看做工业标准。也就是说，并不是所有的数据库都可套用归一化标准。

#### 第一范式

该范式说明在表中每一个单元格都只能有一个值，不应该存放一个列表。

Produclt ID | Color | Price
 --- | --- | ---
 1 | brown, yellow | $15
 2 | red, green | $13
 3 | blue, orange | $11
 
 我们可能尝试使用单独的一行去解决这个问题，但这个也违背了该准则：一个表包含重复的或者紧紧相关的一组（群）属性。
 
|Products|
| --- |
|Color1 <br> Color2<br> Color3<br> Price|

相反，将其分入多个表或几轮中至每一个单元格至有一个值且没有其他列。此刻，数据具有原子性（原子不能再分~~，不要扯夸克~~）。上表，我们可以创建一个“销售细节”表，该表匹配销售商品的细节。“销售”表与“销售细节”有了一对多关系。

#### 第二范式
该范式要求每一属性完全依赖于主键。属性要直接依赖于主键，而不能间接通过其他属性依赖主键。

如年龄属性依赖于生日属性，而生日属性依赖于学号。这意味着年龄属性拥有了偏函数依赖性，这样表就不符合第二范式。

此外，如果主键由多个属性构成而其余一个或者多个属性不依赖于主键的每一部分，则不符合第二范式。

因此，下面的表结构不符合第二范式。因为“product name”依赖于“product ID”而不依赖于“Order number”。

+ Order number (primary key)
+ Product ID (primary key)
+ Product name

#### 第三范式
非主键属性保持独立性。改变一个属性而不改变其他属性。下表中，改变价格就意味着税收也跟着改变。

Order	| Price	    | Tax
 ---	| ---		| ---
14325	| $40.99	|$2.05
14326	| $13.73	|$.69
14327	| $24.15	|$1.21


